### TRY GETTING FIRST MB, LAST MB, AND RANDOM MIDDLE MB ###
### THEN SCALE TO DOUBLE OF EACH, THEN TRIPLE, THEN QUADRUPLE ###

import json
import boto3
import requests
import os
import time
from collections import Counter

s3 = boto3.client('s3')
sagemaker_runtime = boto3.client('runtime.sagemaker')

def lambda_handler(event, context):
    
    # Print the complete event and the QSPs for logging purposes
    print("EVENT:", event)
    print("QSPs:", event["queryStringParameters"])

    # Determine if the user entered a pre-signed URL
    # Note: when testing in Lambda, the complete URL is the only QSP
    # This may also be the case for other methods of calling the API
    try:
        url = event["queryStringParameters"]["url"]
    except:
        errorMessage = "Please include an S3 presigned URL."
        responseBody = {
            "statusCode": 200,
            "body": json.dumps({'errorMessage': errorMessage})
        }
        return responseBody
    
    # Create an empty payload that will only be filled if QSPs match
    payload = {}
    
    # Determine if the user added CLI V2 QSPs and combine them into a payload
    try:
        XAmzCredential = event["queryStringParameters"]["X-Amz-Credential"]
        XAmzDate = event["queryStringParameters"]["X-Amz-Date"]
        XAmzExpires = event["queryStringParameters"]["X-Amz-Expires"]
        XAmzSignedHeaders = event["queryStringParameters"]["X-Amz-SignedHeaders"]
        XAmzSignature = event["queryStringParameters"]["X-Amz-Signature"]
    except:
        pass
    
    # Create a payload with the AWS CLI V2 QSPs
    try:
        payload = {
                    'X-Amz-Credential': XAmzCredential,
                    'X-Amz-Date': XAmzDate,
                    'X-Amz-Expires': XAmzExpires,
                    'X-Amz-SignedHeaders': XAmzSignedHeaders,
                    'X-Amz-Signature': XAmzSignature
        }
    except:
        pass

    # Determine if the user added CLI V1 QSPs and combine them into a payload
    # Check if an Expires parameter was included
    try:
        Expires = event["queryStringParameters"]["Expires"]
    except:
        pass
    
    # Check if a Signature parameter was included
    try:
        Signature = event["queryStringParameters"]["Signature"]
    except:
        pass
    
    # Create a payload with the Expires and Signature parameters
    try:
        payload = {'Expires': Expires, 'Signature': Signature}
    except:
        pass
    
    # Check if the front-end passed in the estimated file type
    try:
        estimateFileType = event["queryStringParameters"]['EstimateFileType']
        print(estimateFileType)
    except:
        pass
    
    # Check if the front-end passed in the user's email
    try:
        email = event["queryStringParameters"]['email']
        print(email)
    except:
        pass
    
    # Check if the front-end passed in the user's full name
    try:
        fullName = event["queryStringParameters"]['fullName']
        print(fullName)
    except:
        pass
    
    # Check if the user wants to scan for malware (True/False boolean)
    try:
        malwareCheck = event["queryStringParameters"]['malwareCheck']
        print(malwareCheck)
    except:
        malwareCheck = False
    
    print("PAYLOAD:",payload)
    
    # Check if the URL is valid before proceeding
    # First determine the size of the file without downloading into memory
    try:
        fileSize = int(requests.get(url, params=payload, stream=True).headers['Content-length'])
        print("TOTAL SIZE:", fileSize)
    except:
        errorMessage = "This URL cannot be processed. Please confirm that all parameters are valid."
        responseBody = {
            "statusCode": 200,
            "body": json.dumps({'errorMessage': errorMessage})
        }
        return responseBody
            
    
    # Retrieve the first and last MB using the requests library
    try:
        headers = {"Range": "bytes=0-999999"}
        r = requests.get(url, headers=headers, params=payload, stream = True)
        print("URL:", r.url)
        # Return the file type according to what S3 has determined.
        fileType = str(r.headers['content-type'])
        print("CONTENT TYPE (S3):", fileType)

        # Create a temporary file called 'MyFile' to store the bytes
        filename="/tmp/MyFile"
        # Process the first and last 1 MB in chunks of 50KB
        with open(filename, 'wb') as fd:
            for chunk in r.iter_content(chunk_size=50000):
                fd.write(chunk)
            r.close()
            
            # Check if the file is between 1MB and 2MB in size
            if  1000000 < fileSize <= 2000000:
                headers = {"Range": "bytes=1000000-"}
                r1 = requests.get(url, headers=headers, params=payload, stream = True)
                for chunk in r1.iter_content(chunk_size=50000):
                    fd.write(chunk)
                r1.close()
                
            # If the file is more than 2MB in size, get the last MB
            else:
                lastRange = fileSize - 1000000
                lastRangeHeader = "bytes="+str(lastRange)+"-"
                print("LAST BYTE RANGE:",lastRangeHeader)
                headers = {"Range": lastRangeHeader}
                r1 = requests.get(url, headers=headers, params=payload, stream = True)
                for chunk in r1.iter_content(chunk_size=50000):
                    fd.write(chunk)
                r1.close()
        fd.close()
        
        # construct byte frequency array
        frequencies = [0 for i in range(0, 256)]
        with open(filename, 'rb') as fd:
            contents = fd.read()
            c = Counter(contents)
            l = c.most_common(256)
            l.sort()
            for value, frequency in l:
                frequencies[value] = frequency
                
        print(frequencies)
        
        byte_string = ""
        
        for i in frequencies:
            byte_string = byte_string + "," + str(i)
            
        byte_string = byte_string[1:]
            
        print(byte_string)
                
        # convert byte frequency array into string to pass into Sagemaker        
        # byte_string = ",".join(frequencies)
        
        # construct payload for sagemaker
        sagemaker_payload = {}
        sagemaker_payload["bytes"] = byte_string
        sagemaker_payload = json.dumps(sagemaker_payload)
        
        # sending payload to sagemaker
        sagemaker_response = sagemaker_runtime.invoke_endpoint(EndpointName=os.environ['SAGEMAKER_ENDPOINT'],
                                       ContentType='application/json',
                                       Body=sagemaker_payload)
        print(sagemaker_response)
        sagemaker_result = json.loads(sagemaker_response['Body'].read().decode())
        
        # Check the file size
        print("SENT SIZE:", os.stat("/tmp/MyFile").st_size)
        
        # Only call the Hybrid Analysis API if malwareCheck is True
        print("malwareCheck:", type(malwareCheck), " ", malwareCheck)
        
        # Convert True to string because QSPs are read in as strings
        if malwareCheck == "True":
            # Prepare the headers for the Hybrid Analysis API
            apikey = os.environ['APIKEY']
            haHeaders = {
                'accept': 'application/json',
                'user-agent': 'Falcon Sandbox',
                'api-key': apikey
            }
            
            # Send 'MyFile' to be scanned by the API
            files = {
                'scan_type': (None, 'all'),
                'file': open('/tmp/MyFile', 'rb')
            }
    
            response = requests.post('https://www.hybrid-analysis.com/api/v2/quick-scan/file', headers=haHeaders, files=files)
            fileScanJSON = response.json()
            
            # Get the hash of the file and use it to return the results of the scan
            baseurl = 'https://www.hybrid-analysis.com/api/v2/overview/'
            testHash = fileScanJSON['sha256']
            
            # Sleep the function for 5 seconds to give time for HA to finish analysis
            time.sleep(5)
            
            url = baseurl + testHash
            response = requests.get(url, headers=haHeaders)
            hashScanJSON = response.json()
            print(hashScanJSON)
         
            # Create a response body for the end user
            responseBody = {
                "statusCode": 200,
                "body": json.dumps({
                    'SHA-256 Hash': hashScanJSON['sha256'],
                    'Type (S3)': fileType,
                    'Type (HA)': hashScanJSON['type'],
                    'Verdict': hashScanJSON['verdict'],
                    'Scanners': hashScanJSON['scanners'],
                    'Sagemaker File Type Prediction': sagemaker_result
                    })
            }
            
        else:
            # Create a response body for the end user
            responseBody = {
                "statusCode": 200,
                "body": json.dumps({
                    'Type (S3)': fileType,
                    'Sagemaker File Type Prediction': sagemaker_result
                    })
            }
            
        # Return the hash in a JSON format and the full Hybrid Analysis JSON
        return responseBody
        
    except Exception as e:
        print(e)
        raise e